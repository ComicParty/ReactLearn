# 学习
API、states、props 、样式
## [React 初学者教程 1：React 简介](http://zcfy.baomitu.com/article/introducing-react-1517.html)
总结：React相当于一个UI库。他采用拼装的方式把Web应用给做出来
      组件=零件
      很多组件=很多零件
      拼装
      Web应用=车

[React 初学者教程 2: 创建第一个 React 应用](http://zcfy.baomitu.com/article/building-your-first-react-app-1521.html)
总结：没什么好说的，创建Re应用有两种方法一种，用或者不用组件。
    Re应用是使用JSX书写的，但是浏览器只认识HTML、CSS、JS，不认识JSX。但是不用怕，有两种方法可以使我们写的JSX转成H\C\J。
    下面贴文章的原话：
>要用 React 创建 Web 应用，我们需要一种方式采用 JSX，并将它转换为浏览器可以理解的标准 JavaScript：
如果不这么做，React 应用就无法运行。目前将 JSX 转换为 JavaScript 有两种解决方案：
围绕 Node 以及一些构建工具（比如 Webpack）来设置开发环境。在这种环境中，每次执行构建时，所有 JSX 被自动转换为 JS，放在磁盘上，让我们可以像标准 JavaScript 文件一样引用。
让浏览器在运行时自动将 JSX 转换为 JavaScript。我们直接像 JavaScript 一样用 JSX，浏览器负责剩下的转换。
这两种解决方案都有一席之地，我们来看看各自的影响。
第一种解决方案，虽然开始有点复杂，有点费时，但是是当今现代 Web 开发的方式。除了把 JSX 编译（更精确的说是转译）为 JS 外，这种方法允许我们利用模块、更好的构建工具，以及让创建复杂 Web 应用变得稍微可管理的很多其它特征。
第二种解决方案提供了一种快速而直接的路径，开始花更多时间写代码，更少时间花在开发环境上。要用这个解决方案，我们要做的就是引用一个脚本文件。这个脚本文件负责在页面加载时，将 JSX 转换为 JS，然后我们的 React 应用就开始活起来，这样就不需要折腾开发环境。
在 React 入门阶段，我们打算用第二种方案。那么为什么我们不一直用第二种方案呢？原因是，浏览器每次要花时间把 JSX 翻译为 JS，这对性能是有影响的。在学习如何使用 React 时，这是完全可以接受的，但是在部署应用程序实际使用时，这肯定是完全不能接受的。所以后面我们会在已经熟悉了 React 后，再用第一解决方案，即设置开发环境。
     
  反正我是没有弄懂的啦，以后再说，擦擦，我已经在第四章学了近一个小时。
如果选择了第二种方式（其实对于没有经验的人，没有选择啦，屎味的巧克力也要吃呀。），千万要记住在书写JSX的script中添加`type="text/babel"`,我估计我未解决的问题中就有它造成的。

译文： 展示的代码有误  很多地方少了h1
原文：相同的地方没有错误

文章：最后的代码与上面的代码CSS数值不一样、在JSX部分使用了React.createElement。

## [React 初学者教程 3: React 中的组件](http://zcfy.baomitu.com/article/components-in-react-1524.html)
总结：定义组件的 第一种方式： `React.createClass`
组件分为：
1. 组件定义 
  `var Hello = React.createClass({
    render:function(){
      return(
      <p>eClass({这里有一个大括号，难怪我自己写的代码一直不对，还找不出原因。{this.props.properti}</p>
      );
    }
  );`
2. 组件调用
  `ReactDom.render(
  <div>
  <Hello properti="元素本身的属性（参数），没有写子元素">
  </div>
  );`
组件使用的 属性（相当于函数的 参数）进行数据的传递。
> 访问组件的子元素有更多东西。
例如，如果子元素是一个深层嵌套结构的根，那么  this.props.children 属性返回的是一个数组。
如果子元素只是一个元素（像本例），那么  this.props.children 属性返回的是没有包在一个数组中的单个组件。

译文 「迎接 React 组件」 ：译者把 代码中的英文改成了中文，而且没有在代码中添加 <meta charset="utf-8">，导致中文显示错误。
  并且使用译文的代码出错，解决方法不明。

译文：好吧，回到现实。我们所做的看起来很疯狂，但是只需要把组件当作是一个酷和新的 HTML 标记就可以了，它的功能是你完全可以控制的。
原文：We wrapped our call to the HelloWorld component inside a div element, and if you preview this in your browser, everything still works. Let's go one step further! Instead of having just a single call to HelloWorld, let's make a bunch of calls. 
问题：a cool有没有更好的译法？

## [React 初学者教程 4: 在 React 中设置样式](http://zcfy.baomitu.com/article/styling-in-react-1527.html)
开始学习时间  2017年04月11日 15时03分03秒  
总结：JSX鼓励我们把 样式（css）、HTML、JS放在一起。
CSS在Re中有两种方式   CSS方式（分为选择器、className）、创建 Style 对象(又分为调用的时候 和 定义的时候)
  样式用的 class属性在JSX中写为className，原因是 class 是 JavaScript 中的一个特殊关键字。
Re的CSS书写格式：
>1. 单个单词的 CSS 属性（比如 padding, margin, color）保持不变。
2. 带有短横线的多个单词的 CSS 属性（比如 background-color, font-family, border-radius）变成去掉横线，并且第二个单词的首字母大写的驼峰规则命名的单词。 例如，background-color 变成 backgroundColor, font-family 变成 fontFamily, border-radius 变成 borderRadius。
3. 可以省略 “px” 后缀,对于这些非像素值，你依然要手动添加上后缀。

可以看出使用 Style对象 和 添加元素属性 的写法还是很大不同的
`<div style={letterStyle}></div>`
`<div className="letter"></div>`



译文：代码部分`<script src="<ht ` 
问题：注意多了奇怪的东东

译文：现在我们先忽略不同的 data-reactid 属性
问题：data-reactroot  原文没有问题

译文：看看下面代码中的高亮度行，看看我们是如何做的：
问题：技术问题，无法在代码中添加 高亮度行？

译文：而 React 不会自动添加像素后缀的与数字相关的属性包括：`animationIterationCount, boxFlex, boxFlexGroup, boxOrdinalGroup, columnCount, fillOpacity, flex, flexGrow, flexPositive, flexShrink, flexNegative, flexOrder, fontWeight, lineClamp, lineHeight, opacity, order, orphans, stopOpacity, strokeDashoffset, strokeOpacity, strokeWidth, tabSize, widows, zIndex, zoom`。我希望我可以告诉你，我是不会记住这些信息的，我只是引用[这篇文章](https://facebook.github.io/react/docs/dom-elements.html)！请鼓掌 :P
问题：没有读懂 不懂

  2017年04月11日 17时47分14秒  结束

## [React 初学者教程 5 ：创建复杂的组件](http://zcfy.baomitu.com/article/creating-complex-components-1533.html)
  2017年04月12日 07时46分45秒    2017年04月12日 09时13分19秒  
  创建复杂组件之前应根据样式稿拆分视觉元素，树状结构（即视觉层级）中，会让你对视觉元素如何组织有更好的感觉。这个练习的目标是识别重要的视觉元素，并把它们分拆成父/子排列，直到不能再分为止。
### 1. 拆分组件
### 2. 识别组件
关于样式部分：厂商前缀属性 开头第一个字母是大写的

思考：Re并没有自己创建自定义元素，他只是让HTML元素（div、label）组合在一起，把他们叫做组件，然后把组件添加到页面中
  2017年04月12日 10时57分13秒  结束
总结：。。。。很多理论，回头重看。。。。。。注意当使用对象的方式时，不要忘记加{}
  学习后面的知识总是需要前面的知识。

## [6：传递属性](http://zcfy.baomitu.com/article/transferring-properties-1535.html)
    2017年04月12日 11时16分56秒  
    扩展运算符
完成：  2017年04月12日 12时18分14秒  

## [7：深入 JSX](http://zcfy.baomitu.com/article/meet-jsx-again-1537.html)
  2017年04月12日 12时20分24秒  睡觉   2017年04月12日 12时43分04秒  睡醒
    2017年04月12日 12时46分01秒  开始
总结： 
>JSX 可以放在 render 函数之外，并且可以用作为值，赋值给变量或者属性。
JSX 怪癖：
1. 只能返回一个根节点
2. 不能指定 inline CSS
3. 保留关键字和 className
    JavaScript 有很多不能用作标识符（即变量和属性名）的关键字和值。这些关键字包括：break, case, class, catch, const, continue, debugger, default, delete, do, else, export, extends, finally, for, function, if, import, in, instanceof, new, return, super, switch, this, throw, try, typeof, var, void, while, with, yield。
4. 注释
  如果你指定一个注释作为一个标记的子节点，那么你必须用 { 和 } 把注释包起来，以确保它被解析为一个表达式：
  `ReactDOM.render(
  <div class="slideIn">
    <p class="emphasis">Gabagool!</p>
    {/* I am a child comment */}
    <Label/>
  </div>,
  document.querySelector("#container")
);`
  如果完全在一个标记内部指定注释，那么就不需要用大括号把单行或者多行注释括起来：
  `ReactDOM.render(
  <div class="slideIn">
    <p class="emphasis">Gabagool!</p>
    <Label
      /* This comment
         goes across
         multiple lines */
         className="colorCard" // end of line
    />
  </div>,
  document.querySelector("#container")
);`

下面是我自己注释，在样式中、return中的注释
要注意不能在 `/* */`中加入 `{/* 很重要 要理解这个对象。。。。 */} `
`var Square= React.createClass({  //如果 直接写retrun(); 里面没有内容，就会报错
      render: function(){
        var squareStyle = {
          height:150,
          backgroundColor:this.props.color
          //精华就在 上面这个对象上
        };
        return(
          <div style={squareStyle}></div>
        );
      }
    });

    var Label = React.createClass({
      render : function(){
        var labelStyle = {
          fontFamily:"sans-serif",
          fontWeight:'bold',
          padding:13,
          margin:0,
        };
        return(
          <p style={labelStyle}>{this.props.color}</p>
           /* 很重要 要理解这个对象。。。。 */
          );
      }
    });`
>5. 大小写、HTML 元素和组件(元素要闭合)
  5.1大小写很重要。要表示 HTML 元素，必须确保 HTML 标记是小写字母：
  5.2当表示组件时，组件的名称必须是大写：
6. JSX 可以出现在任何地方
  在很多情况下，JSX 并不是像我们前面看到的示例一样，整齐地排列在一个 render 或者 return 函数内。看看如下示例：
`var swatchComponent = <Swatch color="#2F004F"></Swatch>;
ReactDOM.render(
  <div>
    {swatchComponent}
  </div>,
  document.querySelector("#container")
);`
我们有一个 swatchComponent 变量，该变量被初始化为一行 JSX。当 swatchComponent 变量放在 render 函数内时，Swatch 组件就被初始化。这一切都是有效的，并且在将来当我们学习如何用 JavaScript 生成和操作 JSX 时，我们将会做更多这种事情。

  2017年04月12日 13时15分28秒  完结

## [8：处理状态](http://zcfy.baomitu.com/article/dealing-with-state-in-react-1539.html)
总结：属性、状态的概念：
>到目前为止，我们已经创建的组件都是无状态的（stateless）。它们有从它们的父组件传递进来的属性（亦称 props），但是一旦组件活跃起来，就没有什么能改变它们。一旦属性被设置了，就被当作是不可修变的（immutable）。对于很多交互场景来说，你肯定不想这样子。在一些用户交互发生，或者一些数据从服务器或者其它地方返回过来时，你想能改变组件的外观。
我们所要的是另一种超越属性的在组件上存储数据的方式，即存储可以修改的数据。我们所需要的是称为状态（state）的东西。在本教程中我们打算学习有关状态的一切，以及如何使用状态来创建有状态的组件。
 React 组件暴露的三个 API：
componentDidMount 该方法在组件渲染后被调用(or mounted as React calls it).。
getInitialState 该方法在组件挂载之前运行，并允许你修改组件的 state 对象。
   注意这里的return 用 { 花括号
setState 该方法允许你修改 state 对象的值。


  Re自带的方法：
  1.我们打算用 setInterval 函数每 1000 微秒（即 1秒）调用一段代码。
  2.setState 该方法允许你修改 state 对象的值。
  3.getInitialState 该方法在组件  挂载   之前运行，并允许你修改组件的 state 对象。


问题：这一章代码中 CDN使用的是fb的，版本应该是react-0.14.7.js  ，之前有使用15.3.2的
  2017年04月12日 15时34分59秒  

## [ 9：从数据到 UI](http://zcfy.baomitu.com/article/going-from-data-to-ui-in-react-1541.html)
总结： 
>JSX 实际上是可以放在 render 函数之外，并且可以用作为值，赋值给变量或者属性
  你可以进一步创建一个返回 Circle 组件的函数：

译文：在创建应用时，术语 props、state、组件、JSX 标记、render 方法以及其它 React 主义也许是你脑袋中最后考虑的事情
原文：and other React-isms
问题：这一章代码中 CDN同样使用的是fb的，版本应该是15.0.0

译文：[JSX 可以在任何地方][第一块代码][的第一行] 与原文不符，不可用
原文：[JSX 可以在任何地方][第一块代码]的第一行  缺少 「分号」

译文：
>在每个组件上，我们指定 key 属性，并将其值设置为 colors 数组内的 color 和索引位置的组合。这确保我们动态创建的每个组件最终有一个唯一的标识符，随后 React 就可以用这个唯一的标识符来优化任何将来的 UI 更新。
检查你的控制台!
React 相当擅长当你做错了事时告诉你。例如，如果你动态创建元素/组件，但是没有为它们指定一个 key 属性，你会在控制上中得到如下警告：
Warning: Each child in an array or iterator should have a unique "key" prop. Check the top-level render call using \.
使用 React 时，周期性地检查控制台消息是个好主意。

问题：我检查了，但是没有报错呀 见「9.2.3批量render」 和「9.2.4key」
